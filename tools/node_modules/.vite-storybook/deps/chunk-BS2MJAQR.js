import {
  isJSON,
  parse,
  stringify
} from "./chunk-FCV4JVZS.js";
import {
  require_lib
} from "./chunk-SPQGVBEX.js";
import {
  esm_exports,
  init_es_array_from,
  init_es_array_includes,
  init_es_array_map,
  init_es_function_name,
  init_es_object_assign,
  init_es_object_entries,
  init_es_object_values,
  init_es_string_includes,
  init_esm as init_esm3,
  require_array_from,
  require_object_assign
} from "./chunk-4L4DWGK3.js";
import {
  init_es_symbol,
  init_es_symbol_description,
  init_es_symbol_iterator
} from "./chunk-5VTKAY5I.js";
import {
  init_es_promise
} from "./chunk-WOWEAKIT.js";
import {
  esm_default,
  init_es_array_filter,
  init_es_array_slice,
  init_esm,
  init_web_dom_collections_for_each
} from "./chunk-3HFPERYK.js";
import {
  init_esm as init_esm2,
  logger,
  pretty,
  require_es_regexp_exec
} from "./chunk-4FLQF7IL.js";
import {
  init_es_array_concat,
  init_web_dom_collections_iterator,
  require_create_iterator_constructor,
  require_create_property,
  require_es_array_iterator,
  require_es_string_iterator,
  require_object_create,
  require_object_define_properties,
  require_string_multibyte
} from "./chunk-U6VEKS2Y.js";
import {
  init_es_object_to_string,
  require_an_instance,
  require_an_object,
  require_classof,
  require_create_property_descriptor,
  require_descriptors,
  require_export,
  require_fails,
  require_function_bind_context,
  require_get_built_in,
  require_get_iterator_method,
  require_global,
  require_has,
  require_internal_state,
  require_is_object,
  require_is_pure,
  require_iterate,
  require_redefine,
  require_redefine_all,
  require_set_to_string_tag,
  require_well_known_symbol
} from "./chunk-WW24V2L5.js";
import {
  require_window
} from "./chunk-UJQALO6D.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ACCAMVX6.js";

// ../../node_modules/core-js/internals/is-integer.js
var require_is_integer = __commonJS({
  "../../node_modules/core-js/internals/is-integer.js"(exports, module) {
    var isObject = require_is_object();
    var floor2 = Math.floor;
    module.exports = function isInteger2(it) {
      return !isObject(it) && isFinite(it) && floor2(it) === it;
    };
  }
});

// ../../node_modules/core-js/internals/native-url.js
var require_native_url = __commonJS({
  "../../node_modules/core-js/internals/native-url.js"(exports, module) {
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = !fails(function() {
      var url = new URL("b?a=1&b=2&c=3", "http://a");
      var searchParams = url.searchParams;
      var result = "";
      url.pathname = "c%20d";
      searchParams.forEach(function(value, key) {
        searchParams["delete"]("b");
        result += key + value;
      });
      return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== "http://a/c%20d?a=1&c=3" || searchParams.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !searchParams[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
    });
  }
});

// ../../node_modules/core-js/internals/string-punycode-to-ascii.js
var require_string_punycode_to_ascii = __commonJS({
  "../../node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module) {
    "use strict";
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexNonASCII = /[^\0-\u007E]/;
    var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
    var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
    var baseMinusTMin = base - tMin;
    var floor2 = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    var ucs2decode = function(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    };
    var digitToBasic = function(digit) {
      return digit + 22 + 75 * (digit < 26);
    };
    var adapt = function(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor2(delta / damp) : delta >> 1;
      delta += floor2(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor2(delta / baseMinusTMin);
      }
      return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var encode = function(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var i, currentValue;
      for (i = 0; i < input.length; i++) {
        currentValue = input[i];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor2((maxInt - delta) / handledCPCountPlusOne)) {
          throw RangeError(OVERFLOW_ERROR);
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < n && ++delta > maxInt) {
            throw RangeError(OVERFLOW_ERROR);
          }
          if (currentValue == n) {
            var q = delta;
            for (var k = base; ; k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t)
                break;
              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
              q = floor2(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    module.exports = function(input) {
      var encoded = [];
      var labels = input.toLowerCase().replace(regexSeparators, ".").split(".");
      var i, label;
      for (i = 0; i < labels.length; i++) {
        label = labels[i];
        encoded.push(regexNonASCII.test(label) ? "xn--" + encode(label) : label);
      }
      return encoded.join(".");
    };
  }
});

// ../../node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "../../node_modules/core-js/internals/get-iterator.js"(exports, module) {
    var anObject = require_an_object();
    var getIteratorMethod = require_get_iterator_method();
    module.exports = function(it) {
      var iteratorMethod = getIteratorMethod(it);
      if (typeof iteratorMethod != "function") {
        throw TypeError(String(it) + " is not iterable");
      }
      return anObject(iteratorMethod.call(it));
    };
  }
});

// ../../node_modules/core-js/modules/web.url-search-params.js
var require_web_url_search_params = __commonJS({
  "../../node_modules/core-js/modules/web.url-search-params.js"(exports, module) {
    "use strict";
    require_es_array_iterator();
    var $4 = require_export();
    var getBuiltIn = require_get_built_in();
    var USE_NATIVE_URL2 = require_native_url();
    var redefine2 = require_redefine();
    var redefineAll = require_redefine_all();
    var setToStringTag2 = require_set_to_string_tag();
    var createIteratorConstructor = require_create_iterator_constructor();
    var InternalStateModule2 = require_internal_state();
    var anInstance2 = require_an_instance();
    var hasOwn = require_has();
    var bind = require_function_bind_context();
    var classof = require_classof();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var wellKnownSymbol = require_well_known_symbol();
    var $fetch = getBuiltIn("fetch");
    var Headers = getBuiltIn("Headers");
    var ITERATOR = wellKnownSymbol("iterator");
    var URL_SEARCH_PARAMS = "URLSearchParams";
    var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
    var setInternalState2 = InternalStateModule2.set;
    var getInternalParamsState = InternalStateModule2.getterFor(URL_SEARCH_PARAMS);
    var getInternalIteratorState = InternalStateModule2.getterFor(URL_SEARCH_PARAMS_ITERATOR);
    var plus = /\+/g;
    var sequences = Array(4);
    var percentSequence = function(bytes) {
      return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
    };
    var percentDecode = function(sequence) {
      try {
        return decodeURIComponent(sequence);
      } catch (error) {
        return sequence;
      }
    };
    var deserialize = function(it) {
      var result = it.replace(plus, " ");
      var bytes = 4;
      try {
        return decodeURIComponent(result);
      } catch (error) {
        while (bytes) {
          result = result.replace(percentSequence(bytes--), percentDecode);
        }
        return result;
      }
    };
    var find = /[!'()~]|%20/g;
    var replace = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+"
    };
    var replacer = function(match) {
      return replace[match];
    };
    var serialize = function(it) {
      return encodeURIComponent(it).replace(find, replacer);
    };
    var parseSearchParams = function(result, query) {
      if (query) {
        var attributes = query.split("&");
        var index = 0;
        var attribute, entry;
        while (index < attributes.length) {
          attribute = attributes[index++];
          if (attribute.length) {
            entry = attribute.split("=");
            result.push({
              key: deserialize(entry.shift()),
              value: deserialize(entry.join("="))
            });
          }
        }
      }
    };
    var updateSearchParams = function(query) {
      this.entries.length = 0;
      parseSearchParams(this.entries, query);
    };
    var validateArgumentsLength = function(passed, required) {
      if (passed < required)
        throw TypeError("Not enough arguments");
    };
    var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
      setInternalState2(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        iterator: getIterator(getInternalParamsState(params).entries),
        kind
      });
    }, "Iterator", function next() {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var step = state.iterator.next();
      var entry = step.value;
      if (!step.done) {
        step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
      }
      return step;
    });
    var URLSearchParamsConstructor = function URLSearchParams3() {
      anInstance2(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
      var init = arguments.length > 0 ? arguments[0] : void 0;
      var that = this;
      var entries = [];
      var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
      setInternalState2(that, {
        type: URL_SEARCH_PARAMS,
        entries,
        updateURL: function() {
        },
        updateSearchParams
      });
      if (init !== void 0) {
        if (isObject(init)) {
          iteratorMethod = getIteratorMethod(init);
          if (typeof iteratorMethod === "function") {
            iterator = iteratorMethod.call(init);
            next = iterator.next;
            while (!(step = next.call(iterator)).done) {
              entryIterator = getIterator(anObject(step.value));
              entryNext = entryIterator.next;
              if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done)
                throw TypeError("Expected sequence with length 2");
              entries.push({ key: first.value + "", value: second.value + "" });
            }
          } else
            for (key in init)
              if (hasOwn(init, key))
                entries.push({ key, value: init[key] + "" });
        } else {
          parseSearchParams(entries, typeof init === "string" ? init.charAt(0) === "?" ? init.slice(1) : init : init + "");
        }
      }
    };
    var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
    redefineAll(URLSearchParamsPrototype, {
      append: function append(name, value) {
        validateArgumentsLength(arguments.length, 2);
        var state = getInternalParamsState(this);
        state.entries.push({ key: name + "", value: value + "" });
        state.updateURL();
      },
      "delete": function(name) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var key = name + "";
        var index = 0;
        while (index < entries.length) {
          if (entries[index].key === key)
            entries.splice(index, 1);
          else
            index++;
        }
        state.updateURL();
      },
      get: function get(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = name + "";
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key)
            return entries[index].value;
        }
        return null;
      },
      getAll: function getAll(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = name + "";
        var result = [];
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key)
            result.push(entries[index].value);
        }
        return result;
      },
      has: function has2(name) {
        validateArgumentsLength(arguments.length, 1);
        var entries = getInternalParamsState(this).entries;
        var key = name + "";
        var index = 0;
        while (index < entries.length) {
          if (entries[index++].key === key)
            return true;
        }
        return false;
      },
      set: function set(name, value) {
        validateArgumentsLength(arguments.length, 1);
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var found = false;
        var key = name + "";
        var val = value + "";
        var index = 0;
        var entry;
        for (; index < entries.length; index++) {
          entry = entries[index];
          if (entry.key === key) {
            if (found)
              entries.splice(index--, 1);
            else {
              found = true;
              entry.value = val;
            }
          }
        }
        if (!found)
          entries.push({ key, value: val });
        state.updateURL();
      },
      sort: function sort() {
        var state = getInternalParamsState(this);
        var entries = state.entries;
        var slice = entries.slice();
        var entry, entriesIndex, sliceIndex;
        entries.length = 0;
        for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
          entry = slice[sliceIndex];
          for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
            if (entries[entriesIndex].key > entry.key) {
              entries.splice(entriesIndex, 0, entry);
              break;
            }
          }
          if (entriesIndex === sliceIndex)
            entries.push(entry);
        }
        state.updateURL();
      },
      forEach: function forEach(callback) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : void 0, 3);
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          boundFunction(entry.value, entry.key, this);
        }
      },
      keys: function keys() {
        return new URLSearchParamsIterator(this, "keys");
      },
      values: function values() {
        return new URLSearchParamsIterator(this, "values");
      },
      entries: function entries() {
        return new URLSearchParamsIterator(this, "entries");
      }
    }, { enumerable: true });
    redefine2(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
    redefine2(URLSearchParamsPrototype, "toString", function toString2() {
      var entries = getInternalParamsState(this).entries;
      var result = [];
      var index = 0;
      var entry;
      while (index < entries.length) {
        entry = entries[index++];
        result.push(serialize(entry.key) + "=" + serialize(entry.value));
      }
      return result.join("&");
    }, { enumerable: true });
    setToStringTag2(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    $4({ global: true, forced: !USE_NATIVE_URL2 }, {
      URLSearchParams: URLSearchParamsConstructor
    });
    if (!USE_NATIVE_URL2 && typeof $fetch == "function" && typeof Headers == "function") {
      $4({ global: true, enumerable: true, forced: true }, {
        fetch: function fetch(input) {
          var args = [input];
          var init, body, headers;
          if (arguments.length > 1) {
            init = arguments[1];
            if (isObject(init)) {
              body = init.body;
              if (classof(body) === URL_SEARCH_PARAMS) {
                headers = init.headers ? new Headers(init.headers) : new Headers();
                if (!headers.has("content-type")) {
                  headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
                init = create(init, {
                  body: createPropertyDescriptor(0, String(body)),
                  headers: createPropertyDescriptor(0, headers)
                });
              }
            }
            args.push(init);
          }
          return $fetch.apply(this, args);
        }
      });
    }
    module.exports = {
      URLSearchParams: URLSearchParamsConstructor,
      getState: getInternalParamsState
    };
  }
});

// ../../node_modules/@storybook/channel-postmessage/dist/esm/index.js
var import_es_array_iterator = __toESM(require_es_array_iterator());

// ../../node_modules/core-js/modules/es.object.from-entries.js
var $ = require_export();
var iterate = require_iterate();
var createProperty = require_create_property();
$({ target: "Object", stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function(k, v) {
      createProperty(obj, k, v);
    }, { AS_ENTRIES: true });
    return obj;
  }
});

// ../../node_modules/@storybook/channel-postmessage/dist/esm/index.js
init_es_array_filter();
init_es_object_to_string();
init_es_object_entries();
init_es_object_assign();

// ../../node_modules/core-js/modules/es.number.is-integer.js
var $2 = require_export();
var isInteger = require_is_integer();
$2({ target: "Number", stat: true }, {
  isInteger
});

// ../../node_modules/@storybook/channel-postmessage/dist/esm/index.js
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
init_es_promise();
init_web_dom_collections_for_each();
init_es_array_map();
init_es_array_includes();
init_es_string_includes();
init_es_object_values();
init_es_array_concat();
var import_es_string_iterator = __toESM(require_es_string_iterator());
init_web_dom_collections_iterator();

// ../../node_modules/core-js/modules/web.url.js
require_es_string_iterator();
var $3 = require_export();
var DESCRIPTORS = require_descriptors();
var USE_NATIVE_URL = require_native_url();
var global = require_global();
var defineProperties = require_object_define_properties();
var redefine = require_redefine();
var anInstance = require_an_instance();
var has = require_has();
var assign = require_object_assign();
var arrayFrom = require_array_from();
var codeAt = require_string_multibyte().codeAt;
var toASCII = require_string_punycode_to_ascii();
var setToStringTag = require_set_to_string_tag();
var URLSearchParamsModule = require_web_url_search_params();
var InternalStateModule = require_internal_state();
var NativeURL = global.URL;
var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor("URL");
var floor = Math.floor;
var pow = Math.pow;
var INVALID_AUTHORITY = "Invalid authority";
var INVALID_SCHEME = "Invalid scheme";
var INVALID_HOST = "Invalid host";
var INVALID_PORT = "Invalid port";
var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
var FORBIDDEN_HOST_CODE_POINT = /[\u0000\t\u000A\u000D #%/:?@[\\]]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\t\u000A\u000D #/:?@[\\]]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g;
var EOF;
var parseHost = function(url, input) {
  var result, codePoints, index;
  if (input.charAt(0) == "[") {
    if (input.charAt(input.length - 1) != "]")
      return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result)
      return INVALID_HOST;
    url.host = result;
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))
      return INVALID_HOST;
    result = "";
    codePoints = arrayFrom(input);
    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }
    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input))
      return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null)
      return INVALID_HOST;
    url.host = result;
  }
};
var parseIPv4 = function(input) {
  var parts = input.split(".");
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == "") {
    parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4)
    return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == "")
      return input;
    radix = 10;
    if (part.length > 1 && part.charAt(0) == "0") {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }
    if (part === "") {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part))
        return input;
      number = parseInt(part, radix);
    }
    numbers.push(number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength))
        return null;
    } else if (number > 255)
      return null;
  }
  ipv4 = numbers.pop();
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};
var parseIPv6 = function(input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
  var char = function() {
    return input.charAt(pointer);
  };
  if (char() == ":") {
    if (input.charAt(1) != ":")
      return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8)
      return;
    if (char() == ":") {
      if (compress !== null)
        return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == ".") {
      if (length == 0)
        return;
      pointer -= length;
      if (pieceIndex > 6)
        return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == "." && numbersSeen < 4)
            pointer++;
          else
            return;
        }
        if (!DIGIT.test(char()))
          return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null)
            ipv4Piece = number;
          else if (ipv4Piece == 0)
            return;
          else
            ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255)
            return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4)
          pieceIndex++;
      }
      if (numbersSeen != 4)
        return;
      break;
    } else if (char() == ":") {
      pointer++;
      if (!char())
        return;
    } else if (char())
      return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8)
    return;
  return address;
};
var findLongestZeroSequence = function(ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null)
        currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};
var serializeHost = function(host) {
  var result, index, compress, ignore0;
  if (typeof host == "number") {
    result = [];
    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor(host / 256);
    }
    return result.join(".");
  } else if (typeof host == "object") {
    result = "";
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0)
        continue;
      if (ignore0)
        ignore0 = false;
      if (compress === index) {
        result += index ? ":" : "::";
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7)
          result += ":";
      }
    }
    return "[" + result + "]";
  }
  return host;
};
var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  " ": 1,
  '"': 1,
  "<": 1,
  ">": 1,
  "`": 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  "#": 1,
  "?": 1,
  "{": 1,
  "}": 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  "/": 1,
  ":": 1,
  ";": 1,
  "=": 1,
  "@": 1,
  "[": 1,
  "\\": 1,
  "]": 1,
  "^": 1,
  "|": 1
});
var percentEncode = function(char, set) {
  var code = codeAt(char, 0);
  return code > 32 && code < 127 && !has(set, char) ? char : encodeURIComponent(char);
};
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var isSpecial = function(url) {
  return has(specialSchemes, url.scheme);
};
var includesCredentials = function(url) {
  return url.username != "" || url.password != "";
};
var cannotHaveUsernamePasswordPort = function(url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == "file";
};
var isWindowsDriveLetter = function(string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ":" || !normalized && second == "|");
};
var startsWithWindowsDriveLetter = function(string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === "/" || third === "\\" || third === "?" || third === "#"));
};
var shortenURLsPath = function(url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != "file" || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};
var isSingleDot = function(segment) {
  return segment === "." || segment.toLowerCase() === "%2e";
};
var isDoubleDot = function(segment) {
  segment = segment.toLowerCase();
  return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
};
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};
var parseURL = function(url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = "";
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;
  if (!stateOverride) {
    url.scheme = "";
    url.username = "";
    url.password = "";
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, "");
  }
  input = input.replace(TAB_AND_NEW_LINE, "");
  codePoints = arrayFrom(input);
  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else
          return INVALID_SCHEME;
        break;
      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == "+" || char == "-" || char == ".")) {
          buffer += char.toLowerCase();
        } else if (char == ":") {
          if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == "file" && (includesCredentials(url) || url.port !== null) || url.scheme == "file" && !url.host))
            return;
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port)
              url.port = null;
            return;
          }
          buffer = "";
          if (url.scheme == "file") {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == "/") {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push("");
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = "";
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else
          return INVALID_SCHEME;
        break;
      case NO_SCHEME:
        if (!base || base.cannotBeABaseURL && char != "#")
          return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == "#") {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = "";
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == "file" ? FILE : RELATIVE;
        continue;
      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == "/" && codePoints[pointer + 1] == "/") {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        }
        break;
      case PATH_OR_AUTHORITY:
        if (char == "/") {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }
      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == "/" || char == "\\" && isSpecial(url)) {
          state = RELATIVE_SLASH;
        } else if (char == "?") {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = "";
          state = QUERY;
        } else if (char == "#") {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = "";
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        }
        break;
      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == "/" || char == "\\")) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == "/") {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        }
        break;
      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != "/" || buffer.charAt(pointer + 1) != "/")
          continue;
        pointer++;
        break;
      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != "/" && char != "\\") {
          state = AUTHORITY;
          continue;
        }
        break;
      case AUTHORITY:
        if (char == "@") {
          if (seenAt)
            buffer = "%40" + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ":" && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken)
              url.password += encodedCodePoints;
            else
              url.username += encodedCodePoints;
          }
          buffer = "";
        } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url)) {
          if (seenAt && buffer == "")
            return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = "";
          state = HOST;
        } else
          buffer += char;
        break;
      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == "file") {
          state = FILE_HOST;
          continue;
        } else if (char == ":" && !seenBracket) {
          if (buffer == "")
            return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure)
            return failure;
          buffer = "";
          state = PORT;
          if (stateOverride == HOSTNAME)
            return;
        } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url)) {
          if (isSpecial(url) && buffer == "")
            return INVALID_HOST;
          if (stateOverride && buffer == "" && (includesCredentials(url) || url.port !== null))
            return;
          failure = parseHost(url, buffer);
          if (failure)
            return failure;
          buffer = "";
          state = PATH_START;
          if (stateOverride)
            return;
          continue;
        } else {
          if (char == "[")
            seenBracket = true;
          else if (char == "]")
            seenBracket = false;
          buffer += char;
        }
        break;
      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (char == EOF || char == "/" || char == "?" || char == "#" || char == "\\" && isSpecial(url) || stateOverride) {
          if (buffer != "") {
            var port = parseInt(buffer, 10);
            if (port > 65535)
              return INVALID_PORT;
            url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
            buffer = "";
          }
          if (stateOverride)
            return;
          state = PATH_START;
          continue;
        } else
          return INVALID_PORT;
        break;
      case FILE:
        url.scheme = "file";
        if (char == "/" || char == "\\")
          state = FILE_SLASH;
        else if (base && base.scheme == "file") {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == "?") {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = "";
            state = QUERY;
          } else if (char == "#") {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = "";
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        }
        break;
      case FILE_SLASH:
        if (char == "/" || char == "\\") {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == "file" && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
          if (isWindowsDriveLetter(base.path[0], true))
            url.path.push(base.path[0]);
          else
            url.host = base.host;
        }
        state = PATH;
        continue;
      case FILE_HOST:
        if (char == EOF || char == "/" || char == "\\" || char == "?" || char == "#") {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == "") {
            url.host = "";
            if (stateOverride)
              return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure)
              return failure;
            if (url.host == "localhost")
              url.host = "";
            if (stateOverride)
              return;
            buffer = "";
            state = PATH_START;
          }
          continue;
        } else
          buffer += char;
        break;
      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != "/" && char != "\\")
            continue;
        } else if (!stateOverride && char == "?") {
          url.query = "";
          state = QUERY;
        } else if (!stateOverride && char == "#") {
          url.fragment = "";
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != "/")
            continue;
        }
        break;
      case PATH:
        if (char == EOF || char == "/" || char == "\\" && isSpecial(url) || !stateOverride && (char == "?" || char == "#")) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != "/" && !(char == "\\" && isSpecial(url))) {
              url.path.push("");
            }
          } else if (isSingleDot(buffer)) {
            if (char != "/" && !(char == "\\" && isSpecial(url))) {
              url.path.push("");
            }
          } else {
            if (url.scheme == "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host)
                url.host = "";
              buffer = buffer.charAt(0) + ":";
            }
            url.path.push(buffer);
          }
          buffer = "";
          if (url.scheme == "file" && (char == EOF || char == "?" || char == "#")) {
            while (url.path.length > 1 && url.path[0] === "") {
              url.path.shift();
            }
          }
          if (char == "?") {
            url.query = "";
            state = QUERY;
          } else if (char == "#") {
            url.fragment = "";
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        }
        break;
      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == "?") {
          url.query = "";
          state = QUERY;
        } else if (char == "#") {
          url.fragment = "";
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        }
        break;
      case QUERY:
        if (!stateOverride && char == "#") {
          url.fragment = "";
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url))
            url.query += "%27";
          else if (char == "#")
            url.query += "%23";
          else
            url.query += percentEncode(char, C0ControlPercentEncodeSet);
        }
        break;
      case FRAGMENT:
        if (char != EOF)
          url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }
    pointer++;
  }
};
var URLConstructor = function URL2(url) {
  var that = anInstance(this, URLConstructor, "URL");
  var base = arguments.length > 1 ? arguments[1] : void 0;
  var urlString = String(url);
  var state = setInternalState(that, { type: "URL" });
  var baseState, failure;
  if (base !== void 0) {
    if (base instanceof URLConstructor)
      baseState = getInternalURLState(base);
    else {
      failure = parseURL(baseState = {}, String(base));
      if (failure)
        throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure)
    throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams2();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function() {
    state.query = String(searchParams) || null;
  };
  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};
var URLPrototype = URLConstructor.prototype;
var serializeURL = function() {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ":";
  if (host !== null) {
    output += "//";
    if (includesCredentials(url)) {
      output += username + (password ? ":" + password : "") + "@";
    }
    output += serializeHost(host);
    if (port !== null)
      output += ":" + port;
  } else if (scheme == "file")
    output += "//";
  output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + path.join("/") : "";
  if (query !== null)
    output += "?" + query;
  if (fragment !== null)
    output += "#" + fragment;
  return output;
};
var getOrigin = function() {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == "blob")
    try {
      return new URL(scheme.path[0]).origin;
    } catch (error) {
      return "null";
    }
  if (scheme == "file" || !isSpecial(url))
    return "null";
  return scheme + "://" + serializeHost(url.host) + (port !== null ? ":" + port : "");
};
var getProtocol = function() {
  return getInternalURLState(this).scheme + ":";
};
var getUsername = function() {
  return getInternalURLState(this).username;
};
var getPassword = function() {
  return getInternalURLState(this).password;
};
var getHost = function() {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
};
var getHostname = function() {
  var host = getInternalURLState(this).host;
  return host === null ? "" : serializeHost(host);
};
var getPort = function() {
  var port = getInternalURLState(this).port;
  return port === null ? "" : String(port);
};
var getPathname = function() {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? "/" + path.join("/") : "";
};
var getSearch = function() {
  var query = getInternalURLState(this).query;
  return query ? "?" + query : "";
};
var getSearchParams = function() {
  return getInternalURLState(this).searchParams;
};
var getHash = function() {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? "#" + fragment : "";
};
var accessorDescriptor = function(getter, setter) {
  return { get: getter, set: setter, configurable: true, enumerable: true };
};
if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    href: accessorDescriptor(serializeURL, function(href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure)
        throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    origin: accessorDescriptor(getOrigin),
    protocol: accessorDescriptor(getProtocol, function(protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ":", SCHEME_START);
    }),
    username: accessorDescriptor(getUsername, function(username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url))
        return;
      url.username = "";
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    password: accessorDescriptor(getPassword, function(password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url))
        return;
      url.password = "";
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    host: accessorDescriptor(getHost, function(host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL)
        return;
      parseURL(url, String(host), HOST);
    }),
    hostname: accessorDescriptor(getHostname, function(hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL)
        return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    port: accessorDescriptor(getPort, function(port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url))
        return;
      port = String(port);
      if (port == "")
        url.port = null;
      else
        parseURL(url, port, PORT);
    }),
    pathname: accessorDescriptor(getPathname, function(pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL)
        return;
      url.path = [];
      parseURL(url, pathname + "", PATH_START);
    }),
    search: accessorDescriptor(getSearch, function(search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == "") {
        url.query = null;
      } else {
        if ("?" == search.charAt(0))
          search = search.slice(1);
        url.query = "";
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    searchParams: accessorDescriptor(getSearchParams),
    hash: accessorDescriptor(getHash, function(hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == "") {
        url.fragment = null;
        return;
      }
      if ("#" == hash.charAt(0))
        hash = hash.slice(1);
      url.fragment = "";
      parseURL(url, hash, FRAGMENT);
    })
  });
}
redefine(URLPrototype, "toJSON", function toJSON() {
  return serializeURL.call(this);
}, { enumerable: true });
redefine(URLPrototype, "toString", function toString() {
  return serializeURL.call(this);
}, { enumerable: true });
if (NativeURL) {
  nativeCreateObjectURL = NativeURL.createObjectURL;
  nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  if (nativeCreateObjectURL)
    redefine(URLConstructor, "createObjectURL", function createObjectURL(blob) {
      return nativeCreateObjectURL.apply(NativeURL, arguments);
    });
  if (nativeRevokeObjectURL)
    redefine(URLConstructor, "revokeObjectURL", function revokeObjectURL(url) {
      return nativeRevokeObjectURL.apply(NativeURL, arguments);
    });
}
var nativeCreateObjectURL;
var nativeRevokeObjectURL;
setToStringTag(URLConstructor, "URL");
$3({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});

// ../../node_modules/@storybook/channel-postmessage/dist/esm/index.js
var import_web_url_search_params = __toESM(require_web_url_search_params());
init_es_array_slice();
init_es_symbol();
init_es_symbol_description();
init_es_symbol_iterator();
init_es_function_name();
init_es_array_from();
var import_global = __toESM(require_window());
init_esm3();
init_esm();
init_esm2();
var import_qs = __toESM(require_lib());
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var globalWindow = import_global.default.window;
var document = import_global.default.document;
var location = import_global.default.location;
var KEY = "storybook-channel";
var defaultEventOptions = {
  allowFunction: true,
  maxDepth: 25
};
var PostmsgTransport = function() {
  function PostmsgTransport2(config) {
    _classCallCheck(this, PostmsgTransport2);
    this.config = config;
    this.buffer = void 0;
    this.handler = void 0;
    this.connected = void 0;
    this.buffer = [];
    this.handler = null;
    globalWindow.addEventListener("message", this.handleEvent.bind(this), false);
    if (config.page !== "manager" && config.page !== "preview") {
      throw new Error('postmsg-channel: "config.page" cannot be "'.concat(config.page, '"'));
    }
  }
  _createClass(PostmsgTransport2, [{
    key: "setHandler",
    value: function setHandler(handler) {
      var _this = this;
      this.handler = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        handler.apply(_this, args);
        if (!_this.connected && _this.getLocalFrame().length) {
          _this.flush();
          _this.connected = true;
        }
      };
    }
  }, {
    key: "send",
    value: function send(event, options) {
      var _this2 = this;
      var _ref = options || {}, target = _ref.target, allowRegExp = _ref.allowRegExp, allowFunction = _ref.allowFunction, allowSymbol = _ref.allowSymbol, allowDate = _ref.allowDate, allowUndefined = _ref.allowUndefined, allowClass = _ref.allowClass, maxDepth = _ref.maxDepth, space = _ref.space, lazyEval = _ref.lazyEval;
      var eventOptions = Object.fromEntries(Object.entries({
        allowRegExp,
        allowFunction,
        allowSymbol,
        allowDate,
        allowUndefined,
        allowClass,
        maxDepth,
        space,
        lazyEval
      }).filter(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), k = _ref3[0], v = _ref3[1];
        return typeof v !== "undefined";
      }));
      var stringifyOptions = Object.assign({}, defaultEventOptions, import_global.default.CHANNEL_OPTIONS || {}, eventOptions);
      if (options && Number.isInteger(options.depth)) {
        stringifyOptions.maxDepth = options.depth;
      }
      var frames = this.getFrames(target);
      var query = import_qs.default.parse(location.search, {
        ignoreQueryPrefix: true
      });
      var data = stringify({
        key: KEY,
        event,
        refId: query.refId
      }, stringifyOptions);
      if (!frames.length) {
        return new Promise(function(resolve, reject) {
          _this2.buffer.push({
            event,
            resolve,
            reject
          });
        });
      }
      if (this.buffer.length) {
        this.flush();
      }
      frames.forEach(function(f) {
        try {
          f.postMessage(data, "*");
        } catch (e) {
          console.error("sending over postmessage fail");
        }
      });
      return Promise.resolve(null);
    }
  }, {
    key: "flush",
    value: function flush() {
      var _this3 = this;
      var buffer = this.buffer;
      this.buffer = [];
      buffer.forEach(function(item) {
        _this3.send(item.event).then(item.resolve).catch(item.reject);
      });
    }
  }, {
    key: "getFrames",
    value: function getFrames(target) {
      if (this.config.page === "manager") {
        var nodes = _toConsumableArray(document.querySelectorAll("iframe[data-is-storybook][data-is-loaded]"));
        var list = nodes.filter(function(e) {
          try {
            return !!e.contentWindow && e.dataset.isStorybook !== void 0 && e.id === target;
          } catch (er) {
            return false;
          }
        }).map(function(e) {
          return e.contentWindow;
        });
        return list.length ? list : this.getCurrentFrames();
      }
      if (globalWindow && globalWindow.parent && globalWindow.parent !== globalWindow) {
        return [globalWindow.parent];
      }
      return [];
    }
  }, {
    key: "getCurrentFrames",
    value: function getCurrentFrames() {
      if (this.config.page === "manager") {
        var list = _toConsumableArray(document.querySelectorAll('[data-is-storybook="true"]'));
        return list.map(function(e) {
          return e.contentWindow;
        });
      }
      if (globalWindow && globalWindow.parent) {
        return [globalWindow.parent];
      }
      return [];
    }
  }, {
    key: "getLocalFrame",
    value: function getLocalFrame() {
      if (this.config.page === "manager") {
        var list = _toConsumableArray(document.querySelectorAll("#storybook-preview-iframe"));
        return list.map(function(e) {
          return e.contentWindow;
        });
      }
      if (globalWindow && globalWindow.parent) {
        return [globalWindow.parent];
      }
      return [];
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(rawEvent) {
      try {
        var data = rawEvent.data;
        var _ref4 = typeof data === "string" && isJSON(data) ? parse(data, import_global.default.CHANNEL_OPTIONS || {}) : data, key = _ref4.key, event = _ref4.event, refId = _ref4.refId;
        if (key === KEY) {
          var pageString = this.config.page === "manager" ? '<span style="color: #37D5D3; background: black"> manager </span>' : '<span style="color: #1EA7FD; background: black"> preview </span>';
          var eventString = Object.values(esm_exports).includes(event.type) ? '<span style="color: #FF4785">'.concat(event.type, "</span>") : '<span style="color: #FFAE00">'.concat(event.type, "</span>");
          if (refId) {
            event.refId = refId;
          }
          event.source = this.config.page === "preview" ? rawEvent.origin : getEventSourceUrl(rawEvent);
          if (!event.source) {
            pretty.error("".concat(pageString, " received ").concat(eventString, " but was unable to determine the source of the event"));
            return;
          }
          var message = "".concat(pageString, " received ").concat(eventString, " (").concat(data.length, ")");
          pretty.debug.apply(pretty, [location.origin !== event.source ? message : "".concat(message, ' <span style="color: gray">(on ').concat(location.origin, " from ").concat(event.source, ")</span>")].concat(_toConsumableArray(event.args)));
          this.handler(event);
        }
      } catch (error) {
        logger.error(error);
      }
    }
  }]);
  return PostmsgTransport2;
}();
var getEventSourceUrl = function getEventSourceUrl2(event) {
  var frames = _toConsumableArray(document.querySelectorAll("iframe[data-is-storybook]"));
  var _frames$filter = frames.filter(function(element) {
    try {
      return element.contentWindow === event.source;
    } catch (err) {
    }
    var src2 = element.getAttribute("src");
    var origin;
    try {
      var _URL = new URL(src2, document.location);
      origin = _URL.origin;
    } catch (err) {
      return false;
    }
    return origin === event.origin;
  }), _frames$filter2 = _toArray(_frames$filter), frame = _frames$filter2[0], remainder = _frames$filter2.slice(1);
  if (frame && remainder.length === 0) {
    var src = frame.getAttribute("src");
    var _URL2 = new URL(src, document.location), protocol = _URL2.protocol, host = _URL2.host, pathname = _URL2.pathname;
    return "".concat(protocol, "//").concat(host).concat(pathname);
  }
  if (remainder.length > 0) {
    logger.error("found multiple candidates for event source");
  }
  return null;
};
function createChannel(_ref5) {
  var page = _ref5.page;
  var transport = new PostmsgTransport({
    page
  });
  return new esm_default({
    transport
  });
}

export {
  KEY,
  PostmsgTransport,
  createChannel
};
//# sourceMappingURL=chunk-BS2MJAQR.js.map
