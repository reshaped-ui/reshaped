import {
  require_engine_is_ios,
  require_task
} from "./chunk-W2M4M4M6.js";
import {
  require_a_function,
  require_an_instance,
  require_an_object,
  require_check_correctness_of_iteration,
  require_engine_is_node,
  require_engine_user_agent,
  require_engine_v8_version,
  require_export,
  require_get_built_in,
  require_global,
  require_inspect_source,
  require_internal_state,
  require_is_forced,
  require_is_object,
  require_is_pure,
  require_iterate,
  require_object_get_own_property_descriptor,
  require_redefine,
  require_redefine_all,
  require_set_species,
  require_set_to_string_tag,
  require_well_known_symbol
} from "./chunk-WW24V2L5.js";
import {
  __commonJS,
  __esm
} from "./chunk-ACCAMVX6.js";

// ../../node_modules/core-js/internals/native-promise-constructor.js
var require_native_promise_constructor = __commonJS({
  "../../node_modules/core-js/internals/native-promise-constructor.js"(exports, module) {
    var global2 = require_global();
    module.exports = global2.Promise;
  }
});

// ../../node_modules/core-js/internals/species-constructor.js
var require_species_constructor = __commonJS({
  "../../node_modules/core-js/internals/species-constructor.js"(exports, module) {
    var anObject = require_an_object();
    var aFunction2 = require_a_function();
    var wellKnownSymbol2 = require_well_known_symbol();
    var SPECIES2 = wellKnownSymbol2("species");
    module.exports = function(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || (S = anObject(C)[SPECIES2]) == void 0 ? defaultConstructor : aFunction2(S);
    };
  }
});

// ../../node_modules/core-js/internals/engine-is-webos-webkit.js
var require_engine_is_webos_webkit = __commonJS({
  "../../node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module) {
    var userAgent = require_engine_user_agent();
    module.exports = /web0s(?!.*chrome)/i.test(userAgent);
  }
});

// ../../node_modules/core-js/internals/microtask.js
var require_microtask = __commonJS({
  "../../node_modules/core-js/internals/microtask.js"(exports, module) {
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var macrotask = require_task().set;
    var IS_IOS = require_engine_is_ios();
    var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
    var IS_NODE2 = require_engine_is_node();
    var MutationObserver = global2.MutationObserver || global2.WebKitMutationObserver;
    var document2 = global2.document;
    var process2 = global2.process;
    var Promise2 = global2.Promise;
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
    var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var flush;
    var head;
    var last;
    var notify2;
    var toggle;
    var node;
    var promise;
    var then;
    if (!queueMicrotask) {
      flush = function() {
        var parent, fn;
        if (IS_NODE2 && (parent = process2.domain))
          parent.exit();
        while (head) {
          fn = head.fn;
          head = head.next;
          try {
            fn();
          } catch (error) {
            if (head)
              notify2();
            else
              last = void 0;
            throw error;
          }
        }
        last = void 0;
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE2 && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
        toggle = true;
        node = document2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify2 = function() {
          node.data = toggle = !toggle;
        };
      } else if (Promise2 && Promise2.resolve) {
        promise = Promise2.resolve(void 0);
        then = promise.then;
        notify2 = function() {
          then.call(promise, flush);
        };
      } else if (IS_NODE2) {
        notify2 = function() {
          process2.nextTick(flush);
        };
      } else {
        notify2 = function() {
          macrotask.call(global2, flush);
        };
      }
    }
    module.exports = queueMicrotask || function(fn) {
      var task2 = { fn, next: void 0 };
      if (last)
        last.next = task2;
      if (!head) {
        head = task2;
        notify2();
      }
      last = task2;
    };
  }
});

// ../../node_modules/core-js/internals/new-promise-capability.js
var require_new_promise_capability = __commonJS({
  "../../node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
    "use strict";
    var aFunction2 = require_a_function();
    var PromiseCapability = function(C) {
      var resolve2, reject2;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve2 !== void 0 || reject2 !== void 0)
          throw TypeError("Bad Promise constructor");
        resolve2 = $$resolve;
        reject2 = $$reject;
      });
      this.resolve = aFunction2(resolve2);
      this.reject = aFunction2(reject2);
    };
    module.exports.f = function(C) {
      return new PromiseCapability(C);
    };
  }
});

// ../../node_modules/core-js/internals/promise-resolve.js
var require_promise_resolve = __commonJS({
  "../../node_modules/core-js/internals/promise-resolve.js"(exports, module) {
    var anObject = require_an_object();
    var isObject2 = require_is_object();
    var newPromiseCapability2 = require_new_promise_capability();
    module.exports = function(C, x) {
      anObject(C);
      if (isObject2(x) && x.constructor === C)
        return x;
      var promiseCapability = newPromiseCapability2.f(C);
      var resolve2 = promiseCapability.resolve;
      resolve2(x);
      return promiseCapability.promise;
    };
  }
});

// ../../node_modules/core-js/internals/host-report-errors.js
var require_host_report_errors = __commonJS({
  "../../node_modules/core-js/internals/host-report-errors.js"(exports, module) {
    var global2 = require_global();
    module.exports = function(a, b) {
      var console = global2.console;
      if (console && console.error) {
        arguments.length === 1 ? console.error(a) : console.error(a, b);
      }
    };
  }
});

// ../../node_modules/core-js/internals/perform.js
var require_perform = __commonJS({
  "../../node_modules/core-js/internals/perform.js"(exports, module) {
    module.exports = function(exec) {
      try {
        return { error: false, value: exec() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
  }
});

// ../../node_modules/core-js/modules/es.promise.js
var $, IS_PURE, global, getBuiltIn, NativePromise, redefine, redefineAll, setToStringTag, setSpecies, isObject, aFunction, anInstance, inspectSource, iterate, checkCorrectnessOfIteration, speciesConstructor, task, microtask, promiseResolve, hostReportErrors, newPromiseCapabilityModule, perform, InternalStateModule, isForced, wellKnownSymbol, IS_NODE, V8_VERSION, SPECIES, PROMISE, getInternalState, setInternalState, getInternalPromiseState, PromiseConstructor, TypeError2, document, process, $fetch, newPromiseCapability, newGenericPromiseCapability, DISPATCH_EVENT, NATIVE_REJECTION_EVENT, UNHANDLED_REJECTION, REJECTION_HANDLED, PENDING, FULFILLED, REJECTED, HANDLED, UNHANDLED, Internal, OwnPromiseCapability, PromiseWrapper, nativeThen, FORCED, INCORRECT_ITERATION, isThenable, notify, dispatchEvent, onUnhandled, isUnhandled, onHandleUnhandled, bind, internalReject, internalResolve;
var init_es_promise = __esm({
  "../../node_modules/core-js/modules/es.promise.js"() {
    "use strict";
    $ = require_export();
    IS_PURE = require_is_pure();
    global = require_global();
    getBuiltIn = require_get_built_in();
    NativePromise = require_native_promise_constructor();
    redefine = require_redefine();
    redefineAll = require_redefine_all();
    setToStringTag = require_set_to_string_tag();
    setSpecies = require_set_species();
    isObject = require_is_object();
    aFunction = require_a_function();
    anInstance = require_an_instance();
    inspectSource = require_inspect_source();
    iterate = require_iterate();
    checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    speciesConstructor = require_species_constructor();
    task = require_task().set;
    microtask = require_microtask();
    promiseResolve = require_promise_resolve();
    hostReportErrors = require_host_report_errors();
    newPromiseCapabilityModule = require_new_promise_capability();
    perform = require_perform();
    InternalStateModule = require_internal_state();
    isForced = require_is_forced();
    wellKnownSymbol = require_well_known_symbol();
    IS_NODE = require_engine_is_node();
    V8_VERSION = require_engine_v8_version();
    SPECIES = wellKnownSymbol("species");
    PROMISE = "Promise";
    getInternalState = InternalStateModule.get;
    setInternalState = InternalStateModule.set;
    getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    PromiseConstructor = NativePromise;
    TypeError2 = global.TypeError;
    document = global.document;
    process = global.process;
    $fetch = getBuiltIn("fetch");
    newPromiseCapability = newPromiseCapabilityModule.f;
    newGenericPromiseCapability = newPromiseCapability;
    DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
    NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == "function";
    UNHANDLED_REJECTION = "unhandledrejection";
    REJECTION_HANDLED = "rejectionhandled";
    PENDING = 0;
    FULFILLED = 1;
    REJECTED = 2;
    HANDLED = 1;
    UNHANDLED = 2;
    FORCED = isForced(PROMISE, function() {
      var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE) {
        if (V8_VERSION === 66)
          return true;
        if (!IS_NODE && !NATIVE_REJECTION_EVENT)
          return true;
      }
      if (IS_PURE && !PromiseConstructor.prototype["finally"])
        return true;
      if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))
        return false;
      var promise = PromiseConstructor.resolve(1);
      var FakePromise = function(exec) {
        exec(function() {
        }, function() {
        });
      };
      var constructor = promise.constructor = {};
      constructor[SPECIES] = FakePromise;
      return !(promise.then(function() {
      }) instanceof FakePromise);
    });
    INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
      PromiseConstructor.all(iterable)["catch"](function() {
      });
    });
    isThenable = function(it) {
      var then;
      return isObject(it) && typeof (then = it.then) == "function" ? then : false;
    };
    notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      var chain = state.reactions;
      microtask(function() {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var index = 0;
        while (chain.length > index) {
          var reaction = chain[index++];
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve2 = reaction.resolve;
          var reject2 = reaction.reject;
          var domain = reaction.domain;
          var result, then, exited;
          try {
            if (handler) {
              if (!ok) {
                if (state.rejection === UNHANDLED)
                  onHandleUnhandled(state);
                state.rejection = HANDLED;
              }
              if (handler === true)
                result = value;
              else {
                if (domain)
                  domain.enter();
                result = handler(value);
                if (domain) {
                  domain.exit();
                  exited = true;
                }
              }
              if (result === reaction.promise) {
                reject2(TypeError2("Promise-chain cycle"));
              } else if (then = isThenable(result)) {
                then.call(result, resolve2, reject2);
              } else
                resolve2(result);
            } else
              reject2(value);
          } catch (error) {
            if (domain && !exited)
              domain.exit();
            reject2(error);
          }
        }
        state.reactions = [];
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    dispatchEvent = function(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document.createEvent("Event");
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global.dispatchEvent(event);
      } else
        event = { promise, reason };
      if (!NATIVE_REJECTION_EVENT && (handler = global["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    onUnhandled = function(state) {
      task.call(global, function() {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function() {
            if (IS_NODE) {
              process.emit("unhandledRejection", value, promise);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    onHandleUnhandled = function(state) {
      task.call(global, function() {
        var promise = state.facade;
        if (IS_NODE) {
          process.emit("rejectionHandled", promise);
        } else
          dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    bind = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw TypeError2("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromiseConstructor, PROMISE);
        aFunction(executor);
        Internal.call(this);
        var state = getInternalState(this);
        try {
          executor(bind(internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: [],
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = redefineAll(PromiseConstructor.prototype, {
        then: function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
          reaction.fail = typeof onRejected == "function" && onRejected;
          reaction.domain = IS_NODE ? process.domain : void 0;
          state.parent = true;
          state.reactions.push(reaction);
          if (state.state != PENDING)
            notify(state, false);
          return reaction.promise;
        },
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && typeof NativePromise == "function") {
        nativeThen = NativePromise.prototype.then;
        redefine(NativePromise.prototype, "then", function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function(resolve2, reject2) {
            nativeThen.call(that, resolve2, reject2);
          }).then(onFulfilled, onRejected);
        }, { unsafe: true });
        if (typeof $fetch == "function")
          $({ global: true, enumerable: true, forced: true }, {
            fetch: function fetch(input) {
              return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
            }
          });
      }
    }
    $({ global: true, wrap: true, forced: FORCED }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
    PromiseWrapper = getBuiltIn(PROMISE);
    $({ target: PROMISE, stat: true, forced: FORCED }, {
      reject: function reject(r) {
        var capability = newPromiseCapability(this);
        capability.reject.call(void 0, r);
        return capability.promise;
      }
    });
    $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
      resolve: function resolve(x) {
        return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
      }
    });
    $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve2 = capability.resolve;
        var reject2 = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aFunction(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function(promise) {
            var index = counter++;
            var alreadyCalled = false;
            values.push(void 0);
            remaining++;
            $promiseResolve.call(C, promise).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve2(values);
            }, reject2);
          });
          --remaining || resolve2(values);
        });
        if (result.error)
          reject2(result.value);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject2 = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aFunction(C.resolve);
          iterate(iterable, function(promise) {
            $promiseResolve.call(C, promise).then(capability.resolve, reject2);
          });
        });
        if (result.error)
          reject2(result.value);
        return capability.promise;
      }
    });
  }
});

export {
  require_species_constructor,
  init_es_promise
};
//# sourceMappingURL=chunk-WOWEAKIT.js.map
