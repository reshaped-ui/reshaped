import {
  FORCE_RE_RENDER,
  RESET_STORY_ARGS,
  STORY_RENDERED,
  UPDATE_GLOBALS,
  UPDATE_STORY_ARGS,
  init_es_array_from,
  init_es_array_includes,
  init_es_array_map,
  init_es_function_name,
  init_es_object_assign,
  init_es_object_entries,
  init_es_object_values,
  init_es_string_includes,
  init_esm as init_esm3
} from "./chunk-4L4DWGK3.js";
import {
  init_es_symbol,
  init_es_symbol_description,
  init_es_symbol_iterator
} from "./chunk-5VTKAY5I.js";
import {
  init_es_promise
} from "./chunk-WOWEAKIT.js";
import {
  esm_default,
  init_es_array_slice,
  init_es_object_keys,
  init_esm,
  init_web_dom_collections_for_each
} from "./chunk-3HFPERYK.js";
import {
  require_array_iteration
} from "./chunk-XVLZZE2S.js";
import {
  init_esm as init_esm2,
  logger,
  require_es_regexp_exec,
  require_es_set
} from "./chunk-4FLQF7IL.js";
import {
  init_es_array_concat,
  init_web_dom_collections_iterator,
  require_add_to_unscopables,
  require_collection,
  require_es_array_iterator,
  require_es_string_iterator,
  require_internal_metadata
} from "./chunk-U6VEKS2Y.js";
import {
  init_es_object_to_string,
  require_an_instance,
  require_an_object,
  require_export,
  require_global,
  require_has,
  require_internal_state,
  require_is_object,
  require_iterate,
  require_native_weak_map,
  require_redefine_all
} from "./chunk-WW24V2L5.js";
import {
  require_window
} from "./chunk-UJQALO6D.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-ACCAMVX6.js";

// ../../node_modules/@storybook/addons/dist/esm/storybook-channel-mock.js
function mockChannel() {
  var transport = {
    setHandler: function setHandler() {
    },
    send: function send() {
    }
  };
  return new esm_default({
    transport
  });
}
var init_storybook_channel_mock = __esm({
  "../../node_modules/@storybook/addons/dist/esm/storybook-channel-mock.js"() {
    init_esm();
  }
});

// ../../node_modules/core-js/modules/es.array.find.js
var $, $find, addToUnscopables, FIND, SKIPS_HOLES;
var init_es_array_find = __esm({
  "../../node_modules/core-js/modules/es.array.find.js"() {
    "use strict";
    $ = require_export();
    $find = require_array_iteration().find;
    addToUnscopables = require_add_to_unscopables();
    FIND = "find";
    SKIPS_HOLES = true;
    if (FIND in [])
      Array(1)[FIND](function() {
        SKIPS_HOLES = false;
      });
    $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
      find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables(FIND);
  }
});

// ../../node_modules/@storybook/addons/dist/esm/types.js
function isSupportedType(type) {
  return !!Object.values(types).find(function(typeVal) {
    return typeVal === type;
  });
}
var types;
var init_types = __esm({
  "../../node_modules/@storybook/addons/dist/esm/types.js"() {
    init_es_array_find();
    init_es_object_to_string();
    init_es_object_values();
    (function(types2) {
      types2["TAB"] = "tab";
      types2["PANEL"] = "panel";
      types2["TOOL"] = "tool";
      types2["TOOLEXTRA"] = "toolextra";
      types2["PREVIEW"] = "preview";
      types2["NOTES_ELEMENT"] = "notes-element";
    })(types || (types = {}));
  }
});

// ../../node_modules/@storybook/addons/dist/esm/index.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function getAddonsStore() {
  if (!import_global.default[KEY]) {
    import_global.default[KEY] = new AddonStore();
  }
  return import_global.default[KEY];
}
var import_global, AddonStore, KEY, addons;
var init_esm4 = __esm({
  "../../node_modules/@storybook/addons/dist/esm/index.js"() {
    init_es_object_assign();
    init_es_object_to_string();
    init_web_dom_collections_for_each();
    init_es_object_values();
    init_es_promise();
    import_global = __toESM(require_window());
    init_esm();
    init_esm2();
    init_storybook_channel_mock();
    init_types();
    AddonStore = _createClass(function AddonStore2() {
      var _this = this;
      _classCallCheck(this, AddonStore2);
      this.loaders = {};
      this.elements = {};
      this.config = {};
      this.channel = void 0;
      this.serverChannel = void 0;
      this.promise = void 0;
      this.resolve = void 0;
      this.getChannel = function() {
        if (!_this.channel) {
          _this.setChannel(mockChannel());
        }
        return _this.channel;
      };
      this.getServerChannel = function() {
        if (!_this.serverChannel) {
          throw new Error("Accessing non-existent serverChannel");
        }
        return _this.serverChannel;
      };
      this.ready = function() {
        return _this.promise;
      };
      this.hasChannel = function() {
        return !!_this.channel;
      };
      this.hasServerChannel = function() {
        return !!_this.serverChannel;
      };
      this.setChannel = function(channel) {
        _this.channel = channel;
        _this.resolve();
      };
      this.setServerChannel = function(channel) {
        _this.serverChannel = channel;
      };
      this.getElements = function(type) {
        if (!_this.elements[type]) {
          _this.elements[type] = {};
        }
        return _this.elements[type];
      };
      this.addPanel = function(name, options) {
        _this.add(name, Object.assign({
          type: types.PANEL
        }, options));
      };
      this.add = function(name, addon) {
        var type = addon.type;
        var collection = _this.getElements(type);
        collection[name] = Object.assign({
          id: name
        }, addon);
      };
      this.setConfig = function(value) {
        Object.assign(_this.config, value);
      };
      this.getConfig = function() {
        return _this.config;
      };
      this.register = function(name, registerCallback) {
        if (_this.loaders[name]) {
          logger.warn("".concat(name, " was loaded twice, this could have bad side-effects"));
        }
        _this.loaders[name] = registerCallback;
      };
      this.loadAddons = function(api) {
        Object.values(_this.loaders).forEach(function(value) {
          return value(api);
        });
      };
      this.promise = new Promise(function(res) {
        _this.resolve = function() {
          return res(_this.getChannel());
        };
      });
    });
    KEY = "__STORYBOOK_ADDONS";
    addons = getAddonsStore();
  }
});

// ../../node_modules/@storybook/addons/dist/esm/make-decorator.js
var makeDecorator;
var init_make_decorator = __esm({
  "../../node_modules/@storybook/addons/dist/esm/make-decorator.js"() {
    init_es_function_name();
    init_es_array_concat();
    makeDecorator = function makeDecorator2(_ref) {
      var name = _ref.name, parameterName = _ref.parameterName, wrapper = _ref.wrapper, _ref$skipIfNoParamete = _ref.skipIfNoParametersOrOptions, skipIfNoParametersOrOptions = _ref$skipIfNoParamete === void 0 ? false : _ref$skipIfNoParamete;
      var decorator = function decorator2(options) {
        return function(storyFn, context) {
          var parameters = context.parameters && context.parameters[parameterName];
          if (parameters && parameters.disable) {
            return storyFn(context);
          }
          if (skipIfNoParametersOrOptions && !options && !parameters) {
            return storyFn(context);
          }
          return wrapper(storyFn, context, {
            options,
            parameters
          });
        };
      };
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (typeof args[0] === "function") {
          return decorator().apply(void 0, args);
        }
        return function() {
          if (arguments.length > 1) {
            if (args.length > 1) {
              return decorator(args).apply(void 0, arguments);
            }
            return decorator.apply(void 0, args).apply(void 0, arguments);
          }
          throw new Error("Passing stories directly into ".concat(name, "() is not allowed,\n        instead use addDecorator(").concat(name, ") and pass options with the '").concat(parameterName, "' parameter"));
        };
      };
    };
  }
});

// ../../node_modules/core-js/internals/collection-weak.js
var require_collection_weak = __commonJS({
  "../../node_modules/core-js/internals/collection-weak.js"(exports, module) {
    "use strict";
    var redefineAll = require_redefine_all();
    var getWeakData = require_internal_metadata().getWeakData;
    var anObject = require_an_object();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var iterate = require_iterate();
    var ArrayIterationModule = require_array_iteration();
    var $has = require_has();
    var InternalStateModule = require_internal_state();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find2 = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var id = 0;
    var uncaughtFrozenStore = function(store) {
      return store.frozen || (store.frozen = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function() {
      this.entries = [];
    };
    var findUncaughtFrozen = function(store, key) {
      return find2(store.entries, function(it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          entry[1] = value;
        else
          this.entries.push([key, value]);
      },
      "delete": function(key) {
        var index = findIndex(this.entries, function(it) {
          return it[0] === key;
        });
        if (~index)
          this.entries.splice(index, 1);
        return !!~index;
      }
    };
    module.exports = {
      getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
          anInstance(that, C, CONSTRUCTOR_NAME);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id++,
            frozen: void 0
          });
          if (iterable != void 0)
            iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        });
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function(that, key, value) {
          var state = getInternalState(that);
          var data = getWeakData(anObject(key), true);
          if (data === true)
            uncaughtFrozenStore(state).set(key, value);
          else
            data[state.id] = value;
          return that;
        };
        redefineAll(C.prototype, {
          "delete": function(key) {
            var state = getInternalState(this);
            if (!isObject(key))
              return false;
            var data = getWeakData(key);
            if (data === true)
              return uncaughtFrozenStore(state)["delete"](key);
            return data && $has(data, state.id) && delete data[state.id];
          },
          has: function has(key) {
            var state = getInternalState(this);
            if (!isObject(key))
              return false;
            var data = getWeakData(key);
            if (data === true)
              return uncaughtFrozenStore(state).has(key);
            return data && $has(data, state.id);
          }
        });
        redefineAll(C.prototype, IS_MAP ? {
          get: function get(key) {
            var state = getInternalState(this);
            if (isObject(key)) {
              var data = getWeakData(key);
              if (data === true)
                return uncaughtFrozenStore(state).get(key);
              return data ? data[state.id] : void 0;
            }
          },
          set: function set(key, value) {
            return define(this, key, value);
          }
        } : {
          add: function add(value) {
            return define(this, value, true);
          }
        });
        return C;
      }
    };
  }
});

// ../../node_modules/core-js/modules/es.weak-map.js
var require_es_weak_map = __commonJS({
  "../../node_modules/core-js/modules/es.weak-map.js"(exports, module) {
    "use strict";
    var global3 = require_global();
    var redefineAll = require_redefine_all();
    var InternalMetadataModule = require_internal_metadata();
    var collection = require_collection();
    var collectionWeak = require_collection_weak();
    var isObject = require_is_object();
    var enforceIternalState = require_internal_state().enforce;
    var NATIVE_WEAK_MAP = require_native_weak_map();
    var IS_IE11 = !global3.ActiveXObject && "ActiveXObject" in global3;
    var isExtensible = Object.isExtensible;
    var InternalWeakMap;
    var wrapper = function(init) {
      return function WeakMap2() {
        return init(this, arguments.length ? arguments[0] : void 0);
      };
    };
    var $WeakMap = module.exports = collection("WeakMap", wrapper, collectionWeak);
    if (NATIVE_WEAK_MAP && IS_IE11) {
      InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
      InternalMetadataModule.REQUIRED = true;
      WeakMapPrototype = $WeakMap.prototype;
      nativeDelete = WeakMapPrototype["delete"];
      nativeHas = WeakMapPrototype.has;
      nativeGet = WeakMapPrototype.get;
      nativeSet = WeakMapPrototype.set;
      redefineAll(WeakMapPrototype, {
        "delete": function(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            return nativeDelete.call(this, key) || state.frozen["delete"](key);
          }
          return nativeDelete.call(this, key);
        },
        has: function has(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            return nativeHas.call(this, key) || state.frozen.has(key);
          }
          return nativeHas.call(this, key);
        },
        get: function get(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
          }
          return nativeGet.call(this, key);
        },
        set: function set(key, value) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen)
              state.frozen = new InternalWeakMap();
            nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
          } else
            nativeSet.call(this, key, value);
          return this;
        }
      });
    }
    var WeakMapPrototype;
    var nativeDelete;
    var nativeHas;
    var nativeGet;
    var nativeSet;
  }
});

// ../../node_modules/@storybook/addons/dist/esm/hooks.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function hookify(fn) {
  return function() {
    var _ref = typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "function" ? arguments.length <= 1 ? void 0 : arguments[1] : arguments.length <= 0 ? void 0 : arguments[0], hooks = _ref.hooks;
    var prevPhase = hooks.currentPhase;
    var prevHooks = hooks.currentHooks;
    var prevNextHookIndex = hooks.nextHookIndex;
    var prevDecoratorName = hooks.currentDecoratorName;
    hooks.currentDecoratorName = fn.name;
    if (hooks.prevMountedDecorators.has(fn)) {
      hooks.currentPhase = "UPDATE";
      hooks.currentHooks = hooks.hookListsMap.get(fn) || [];
    } else {
      hooks.currentPhase = "MOUNT";
      hooks.currentHooks = [];
      hooks.hookListsMap.set(fn, hooks.currentHooks);
      hooks.prevMountedDecorators.add(fn);
    }
    hooks.nextHookIndex = 0;
    var prevContext = globalWindow.STORYBOOK_HOOKS_CONTEXT;
    globalWindow.STORYBOOK_HOOKS_CONTEXT = hooks;
    var result = fn.apply(void 0, arguments);
    globalWindow.STORYBOOK_HOOKS_CONTEXT = prevContext;
    if (hooks.currentPhase === "UPDATE" && hooks.getNextHook() != null) {
      throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    }
    hooks.currentPhase = prevPhase;
    hooks.currentHooks = prevHooks;
    hooks.nextHookIndex = prevNextHookIndex;
    hooks.currentDecoratorName = prevDecoratorName;
    return result;
  };
}
function getHooksContextOrNull() {
  return globalWindow.STORYBOOK_HOOKS_CONTEXT || null;
}
function getHooksContextOrThrow() {
  var hooks = getHooksContextOrNull();
  if (hooks == null) {
    throw invalidHooksError();
  }
  return hooks;
}
function useHook(name, callback, deps) {
  var hooks = getHooksContextOrThrow();
  if (hooks.currentPhase === "MOUNT") {
    if (deps != null && !Array.isArray(deps)) {
      logger.warn("".concat(name, " received a final argument that is not an array (instead, received ").concat(deps, "). When specified, the final argument must be an array."));
    }
    var _hook = {
      name,
      deps
    };
    hooks.currentHooks.push(_hook);
    callback(_hook);
    return _hook;
  }
  if (hooks.currentPhase === "UPDATE") {
    var _hook2 = hooks.getNextHook();
    if (_hook2 == null) {
      throw new Error("Rendered more hooks than during the previous render.");
    }
    if (_hook2.name !== name) {
      logger.warn("Storybook has detected a change in the order of Hooks".concat(hooks.currentDecoratorName ? " called by ".concat(hooks.currentDecoratorName) : "", ". This will lead to bugs and errors if not fixed."));
    }
    if (deps != null && _hook2.deps == null) {
      logger.warn("".concat(name, " received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders."));
    }
    if (deps != null && _hook2.deps != null && deps.length !== _hook2.deps.length) {
      logger.warn("The final argument passed to ".concat(name, " changed size between renders. The order and size of this array must remain constant.\nPrevious: ").concat(_hook2.deps, "\nIncoming: ").concat(deps));
    }
    if (deps == null || _hook2.deps == null || !areDepsEqual(deps, _hook2.deps)) {
      callback(_hook2);
      _hook2.deps = deps;
    }
    return _hook2;
  }
  throw invalidHooksError();
}
function useMemoLike(name, nextCreate, deps) {
  var _useHook = useHook(name, function(hook) {
    hook.memoizedState = nextCreate();
  }, deps), memoizedState = _useHook.memoizedState;
  return memoizedState;
}
function useMemo(nextCreate, deps) {
  return useMemoLike("useMemo", nextCreate, deps);
}
function useCallback(callback, deps) {
  return useMemoLike("useCallback", function() {
    return callback;
  }, deps);
}
function useRefLike(name, initialValue) {
  return useMemoLike(name, function() {
    return {
      current: initialValue
    };
  }, []);
}
function useRef(initialValue) {
  return useRefLike("useRef", initialValue);
}
function triggerUpdate() {
  var hooks = getHooksContextOrNull();
  if (hooks != null && hooks.currentPhase !== "NONE") {
    hooks.hasUpdates = true;
  } else {
    try {
      addons.getChannel().emit(FORCE_RE_RENDER);
    } catch (e) {
      logger.warn("State updates of Storybook preview hooks work only in browser");
    }
  }
}
function useStateLike(name, initialState) {
  var stateRef = useRefLike(name, typeof initialState === "function" ? initialState() : initialState);
  var setState = function setState2(update) {
    stateRef.current = typeof update === "function" ? update(stateRef.current) : update;
    triggerUpdate();
  };
  return [stateRef.current, setState];
}
function useState(initialState) {
  return useStateLike("useState", initialState);
}
function useReducer(reducer, initialArg, init) {
  var initialState = init != null ? function() {
    return init(initialArg);
  } : initialArg;
  var _useStateLike = useStateLike("useReducer", initialState), _useStateLike2 = _slicedToArray(_useStateLike, 2), state = _useStateLike2[0], setState = _useStateLike2[1];
  var dispatch = function dispatch2(action) {
    return setState(function(prevState) {
      return reducer(prevState, action);
    });
  };
  return [state, dispatch];
}
function useEffect(create, deps) {
  var hooks = getHooksContextOrThrow();
  var effect = useMemoLike("useEffect", function() {
    return {
      create
    };
  }, deps);
  if (!hooks.currentEffects.includes(effect)) {
    hooks.currentEffects.push(effect);
  }
}
function useChannel(eventMap) {
  var deps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var channel = addons.getChannel();
  useEffect(function() {
    Object.entries(eventMap).forEach(function(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), type = _ref4[0], listener = _ref4[1];
      return channel.on(type, listener);
    });
    return function() {
      Object.entries(eventMap).forEach(function(_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2), type = _ref6[0], listener = _ref6[1];
        return channel.removeListener(type, listener);
      });
    };
  }, [].concat(_toConsumableArray(Object.keys(eventMap)), _toConsumableArray(deps)));
  return useCallback(channel.emit.bind(channel), [channel]);
}
function useStoryContext() {
  var _getHooksContextOrThr = getHooksContextOrThrow(), currentContext = _getHooksContextOrThr.currentContext;
  if (currentContext == null) {
    throw invalidHooksError();
  }
  return currentContext;
}
function useParameter(parameterKey, defaultValue) {
  var _useStoryContext = useStoryContext(), parameters = _useStoryContext.parameters;
  if (parameterKey) {
    var _parameters$parameter;
    return (_parameters$parameter = parameters[parameterKey]) !== null && _parameters$parameter !== void 0 ? _parameters$parameter : defaultValue;
  }
  return void 0;
}
function useArgs() {
  var channel = addons.getChannel();
  var _useStoryContext2 = useStoryContext(), storyId = _useStoryContext2.id, args = _useStoryContext2.args;
  var updateArgs = useCallback(function(updatedArgs) {
    return channel.emit(UPDATE_STORY_ARGS, {
      storyId,
      updatedArgs
    });
  }, [channel, storyId]);
  var resetArgs = useCallback(function(argNames) {
    return channel.emit(RESET_STORY_ARGS, {
      storyId,
      argNames
    });
  }, [channel, storyId]);
  return [args, updateArgs, resetArgs];
}
function useGlobals() {
  var channel = addons.getChannel();
  var _useStoryContext3 = useStoryContext(), globals = _useStoryContext3.globals;
  var updateGlobals = useCallback(function(newGlobals) {
    return channel.emit(UPDATE_GLOBALS, {
      globals: newGlobals
    });
  }, [channel]);
  return [globals, updateGlobals];
}
var import_es_array_iterator, import_es_string_iterator, import_es_weak_map, import_es_set, import_es_regexp_exec, import_global2, globalWindow, HooksContext, numberOfRenders, RENDER_LIMIT, applyHooks, areDepsEqual, invalidHooksError;
var init_hooks = __esm({
  "../../node_modules/@storybook/addons/dist/esm/hooks.js"() {
    import_es_array_iterator = __toESM(require_es_array_iterator());
    init_es_object_to_string();
    import_es_string_iterator = __toESM(require_es_string_iterator());
    import_es_weak_map = __toESM(require_es_weak_map());
    init_web_dom_collections_iterator();
    import_es_set = __toESM(require_es_set());
    init_web_dom_collections_for_each();
    init_es_array_includes();
    init_es_string_includes();
    init_es_function_name();
    init_es_array_map();
    init_es_array_concat();
    init_es_object_entries();
    init_es_object_keys();
    init_es_symbol();
    init_es_symbol_description();
    init_es_symbol_iterator();
    init_es_array_from();
    init_es_array_slice();
    import_es_regexp_exec = __toESM(require_es_regexp_exec());
    import_global2 = __toESM(require_window());
    init_esm2();
    init_esm3();
    init_esm4();
    globalWindow = import_global2.default.window;
    HooksContext = function() {
      function HooksContext2() {
        var _this = this;
        _classCallCheck2(this, HooksContext2);
        this.hookListsMap = void 0;
        this.mountedDecorators = void 0;
        this.prevMountedDecorators = void 0;
        this.currentHooks = void 0;
        this.nextHookIndex = void 0;
        this.currentPhase = void 0;
        this.currentEffects = void 0;
        this.prevEffects = void 0;
        this.currentDecoratorName = void 0;
        this.hasUpdates = void 0;
        this.currentContext = void 0;
        this.renderListener = function(storyId) {
          if (storyId !== _this.currentContext.id)
            return;
          _this.triggerEffects();
          _this.currentContext = null;
          _this.removeRenderListeners();
        };
        this.init();
      }
      _createClass2(HooksContext2, [{
        key: "init",
        value: function init() {
          this.hookListsMap = /* @__PURE__ */ new WeakMap();
          this.mountedDecorators = /* @__PURE__ */ new Set();
          this.prevMountedDecorators = this.mountedDecorators;
          this.currentHooks = [];
          this.nextHookIndex = 0;
          this.currentPhase = "NONE";
          this.currentEffects = [];
          this.prevEffects = [];
          this.currentDecoratorName = null;
          this.hasUpdates = false;
          this.currentContext = null;
        }
      }, {
        key: "clean",
        value: function clean() {
          this.prevEffects.forEach(function(effect) {
            if (effect.destroy) {
              effect.destroy();
            }
          });
          this.init();
          this.removeRenderListeners();
        }
      }, {
        key: "getNextHook",
        value: function getNextHook() {
          var hook = this.currentHooks[this.nextHookIndex];
          this.nextHookIndex += 1;
          return hook;
        }
      }, {
        key: "triggerEffects",
        value: function triggerEffects() {
          var _this2 = this;
          this.prevEffects.forEach(function(effect) {
            if (!_this2.currentEffects.includes(effect) && effect.destroy) {
              effect.destroy();
            }
          });
          this.currentEffects.forEach(function(effect) {
            if (!_this2.prevEffects.includes(effect)) {
              effect.destroy = effect.create();
            }
          });
          this.prevEffects = this.currentEffects;
          this.currentEffects = [];
        }
      }, {
        key: "addRenderListeners",
        value: function addRenderListeners() {
          this.removeRenderListeners();
          var channel = addons.getChannel();
          channel.on(STORY_RENDERED, this.renderListener);
        }
      }, {
        key: "removeRenderListeners",
        value: function removeRenderListeners() {
          var channel = addons.getChannel();
          channel.removeListener(STORY_RENDERED, this.renderListener);
        }
      }]);
      return HooksContext2;
    }();
    numberOfRenders = 0;
    RENDER_LIMIT = 25;
    applyHooks = function applyHooks2(applyDecorators) {
      return function(storyFn, decorators) {
        var decorated = applyDecorators(hookify(storyFn), decorators.map(function(decorator) {
          return hookify(decorator);
        }));
        return function(context) {
          var _ref2 = context, hooks = _ref2.hooks;
          hooks.prevMountedDecorators = hooks.mountedDecorators;
          hooks.mountedDecorators = new Set([storyFn].concat(_toConsumableArray(decorators)));
          hooks.currentContext = context;
          hooks.hasUpdates = false;
          var result = decorated(context);
          numberOfRenders = 1;
          while (hooks.hasUpdates) {
            hooks.hasUpdates = false;
            hooks.currentEffects = [];
            result = decorated(context);
            numberOfRenders += 1;
            if (numberOfRenders > RENDER_LIMIT) {
              throw new Error("Too many re-renders. Storybook limits the number of renders to prevent an infinite loop.");
            }
          }
          hooks.addRenderListeners();
          return result;
        };
      };
    };
    areDepsEqual = function areDepsEqual2(deps, nextDeps) {
      return deps.length === nextDeps.length && deps.every(function(dep, i) {
        return dep === nextDeps[i];
      });
    };
    invalidHooksError = function invalidHooksError2() {
      return new Error("Storybook preview hooks can only be called inside decorators and story functions.");
    };
  }
});

// ../../node_modules/@storybook/addons/dist/esm/public_api.js
var public_api_default;
var init_public_api = __esm({
  "../../node_modules/@storybook/addons/dist/esm/public_api.js"() {
    init_esm4();
    init_make_decorator();
    init_esm4();
    init_types();
    init_storybook_channel_mock();
    init_hooks();
    public_api_default = addons;
  }
});

export {
  mockChannel,
  init_es_array_find,
  types,
  isSupportedType,
  AddonStore,
  addons,
  makeDecorator,
  HooksContext,
  applyHooks,
  useMemo,
  useCallback,
  useRef,
  useState,
  useReducer,
  useEffect,
  useChannel,
  useStoryContext,
  useParameter,
  useArgs,
  useGlobals,
  public_api_default,
  init_public_api
};
//# sourceMappingURL=chunk-ZLYSAJBM.js.map
